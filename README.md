# Тестовое на вакансию Node.js (Typescript) Backend Developer

MongoDB должен быть частью реплика-сета или шардированной кластерной конфигурации.
[Replica Set](https://www.mongodb.com/docs/manual/tutorial/convert-standalone-to-replica-set/)

Неоходимо создать файл .env с переменной DB_URI которая будет содержать строку подключения к базе данных. Пример файла: 
```
DB_URI="mongodb://localhost:27017"
```

Необходимо проинициализировать проект ззапутив команду
```
npm i
```

Для запуска приложения в режиме генерации документов
```
npm run generate
```
Для запуска приложения в режиме рейлтайм синхронизации (“слушает” появление и изменение документов в коллекции customers и анонимизирует их)
```
npm run sync
```
Для запуска приложения в режиме полная синхронизация
```
npm run reindex
```

Настройки находятся в файле config.ts







# Задача

Предположим, у нас интернет-магазин. Мы храним данные о покупателях в коллекции mongodb. Эти данные содержат много чувствительной персональной информации. Чтобы обеспечить максимальную безопасность, мы хотим, чтобы разработчики имели доступ к свежим записям в этой коллекции, но не имели доступ к персональным данным.

Для решения этой задачи вам нужно создать сервис, который будет следить за появлением и изменением документов в этой коллекции и копировать их в другую, анонимизируя при этом часть полей.

## Структура БД

В mongodb есть коллекция `customers`, где создаются документы такого вида.

```jsx
{
  "_id": ObjectId("64155ece0ac406903b7eb4a1"),
  "firstName": "Cindy",
  "lastName": "Doyle",
  "email": "Cindy.Doyle@hotmail.com",
  "address": {
    "line1": "34801 Kurt Spur",
    "line2": "Suite 028",
    "postcode": "45081",
    "city": "Hailieberg",
    "state": "NY",
    "country": "US"
  },
  "createdAt": ISODate("2022-12-11T19:08:41.683Z")
}
```

Рядом находится коллекция `customers_anonymised`. Куда попадают такие документы.

```jsx
{
  "_id": ObjectId("64155ece0ac406903b7eb4a1"),
  "firstName": "Lba7yaBf",
  "lastName": "mn1aMji3",
  "email": "V83AkoCj@hotmail.com",
  "address": {
    "line1": "cHyd22Ji",
    "line2": "pPa0Ui3b",
    "postcode": "oO15sD6F",
    "city": "Hailieberg",
    "state": "NY",
    "country": "US"
  },
  "createdAt": ISODate("2023-03-20T19:08:41.683Z")
}
```

## Приложение `app.ts`

Это приложение эмулирует работу нашего магазина.

- Приложение вечно генерирует покупателей и вставляет их в БД.
- Для генерации используется библиотека [**Faker**](https://www.npmjs.com/package/@faker-js/faker).
- Покупатели создаются случайными пачками по 1 - 10 покупателей каждые 200 миллисекунд, и так же пачками вставляются в коллекцию `customers`.

## Приложение `sync.ts`

Это приложение копирует и анонимизирует покупателей.

- Приложение “слушает” появление и **изменение** документов в коллекции `customers` и анонимизирует их:
    - Заменяются содержимое полей `firstName`, `lastName`, часть до `@` в поле `email`, `address.line1`, `address.line2` и `postcode`.
    - Значения заменяются на 8-значную псевдослучайную, но детерминированную последовательность символов `[a-zA-Z\d]`.
- После анонимизации записи вставляются в `customers_anonymised` следующим образом:
    - Приложение накапливает пачки по 1,000 документов.
    - Если не удалось накопить пачку за 1 секунду, то вставляется то что есть.
- Приложение может быть перезапущено. В случае перезапуска оно должно продолжить с того места где остановилось, не пропустив те изменения, которые случились пока приложение было оффлайн.
- Приложение можно запустить в двух режимах:
    - Реалтайм синхронизация. Это дефолтное поведение, которое описано выше. Оно работает, если `sync.ts` запущен без аргументов.
    - Полная синхронизация. Включается, при наличии флага `--full-reindex`. В этом режиме приложение вместо того чтобы слушать изменения, должно запуститься и перелить все данные пачками по 1000 документов, анонимизировов их. В случае успеха, приложение завершает свою работу с кодом `0`.
- Оба режима могут работать параллельно. То есть одновременно можно запустить два инстанса — один в реалтайме, второй в режиме полной синхронизации.
- Документы в коллекции `customers` не удаляются, не стоит предусматривать поведение на этот случай.

# Технические требования

- Стек — `Node.js`, `TypeScript` и `mongodb`.
- Весь код должен быть в одном репозитории.
- Приложите файл `README` с описанием процесса сборки и запуска приложений. Не описывайте как установить `mongodb`, предполагается что она уже установлена.
- Приложение должно читать `env` переменные из файла `.env`, строка подключения к базе должна лежать в переменной `DB_URI`. Ни каких других переменных или конфигов у приложения не должно быть.
- Не используйте фреймворки (например, `nestjs`, `express`).
- Приложения при запуске не должны демонизироваться.
- Не используйте громоздких архитектурных паттернов. Проект простой, лучше потратить время на читабельность кода и отладку требований ТЗ.
- Отформатируйте код с помощью [prettier](https://prettier.io/). Используйте дефолтный конфиг.
- При разработке можно использовать Docker, но в итоговом репозитории не должно остаться следов такого использования.
- Вместе со ссылкой на репозиторий пришлите пару слов о том, с какими сложностями пришлось столкнуться в процессе работы над тестовым, а так же сколько времени вы потратили.

# Как мы оцениваем тестовое

Мы очень внимательно проверяем тестовое. Один или два разработчика из нашей команды делают код-ревью и выносят решение. В итоге, все сводится к этим простым критериям:

- [ ]  Код простой и легко читается
- [ ]  Все требования ТЗ выполнены
- [ ]  Нет багов